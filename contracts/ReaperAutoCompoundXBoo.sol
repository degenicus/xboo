// SPDX-License-Identifier: MIT

import "./abstract/Ownable.sol";
import "./abstract/Pausable.sol";
import "./interfaces/IERC20.sol";
import "./interfaces/IAceLab.sol";
import "./interfaces/IBooMirrorWorld.sol";
import "./interfaces/IUniswapRouterETH.sol";
import "./libraries/SafeERC20.sol";
import "./libraries/SafeMath.sol";
import "./libraries/AceLabPoolManager.sol";

pragma solidity 0.8.9;

/**
 * @dev This is a strategy to stake Boo into xBoo, and then stake xBoo in different pools to collect more rewards
 * The strategy will compound the pool rewards into Boo which will be deposited into the strategy for more yield.
 */
contract ReaperAutoCompoundXBoo is Ownable, Pausable {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;
    using AceLabPoolManager for uint8[];

    /**
     * @dev Tokens Used:
     * {wftm} - Required for liquidity routing when doing swaps. Also used to charge fees on yield.
     * {xBoo} - Token generated by staking our funds. Also used to stake in secondary pools.
     * {boo} - Token that the strategy maximizes.
     */
    address public wftm = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);
    address public xBoo;
    address public boo;

    /**
     * @dev Third Party Contracts:
     * {uniRouter} - the uniRouter for target DEX
     * {aceLab} - Address to AceLab, the SpookySwap contract to stake xBoo
     */
    address public uniRouter;
    address public aceLab;

    /**
     * @dev Reaper Contracts:
     * {treasury} - Address of the Reaper treasury
     * {vault} - Address of the vault that controls the strategy's funds.
     */
    address public treasury;
    address public vault;

    /**
     * @dev Distribution of fees earned. This allocations relative to the % implemented on
     * Current implementation separates 5% for fees. Can be changed through the constructor
     * Inputs in constructor should be ratios between the Fee and Max Fee, divisble into percents by 10000
     *
     * {callFee} - Percent of the totalFee reserved for the harvester (1000 = 10% of total fee: 0.5% by default)
     * {treasuryFee} - Percent of the totalFee taken by maintainers of the software (9000 = 90% of total fee: 4.5% by default)
     * {securityFee} - Fee taxed when a user withdraws funds. Taken to prevent flash deposit/harvest attacks.
     * These funds are redistributed to stakers in the pool.
     *
     * {totalFee} - divided by 10,000 to determine the % fee. Set to 5% by default and
     * lowered as necessary to provide users with the most competitive APY.
     *
     * {MAX_FEE} - Maximum fee allowed by the strategy. Hard-capped at 5%.
     * {PERCENT_DIVISOR} - Constant used to safely calculate the correct percentages.
     */

    uint256 public callFee = 1000;
    uint256 public treasuryFee = 9000;
    uint256 public securityFee = 10;
    uint256 public totalFee = 450;
    uint256 public constant MAX_FEE = 500;
    uint256 public constant PERCENT_DIVISOR = 10000;

    /**
     * @dev Routes we take to swap tokens
     * {wftmToBooRoute} - Route we take to get from {wftm} into {boo}.
     * {poolRewardToWftmPaths} - Routes for each pool to get from {pool reward token} into {wftm}.
     */
    address[] public wftmToBooRoute;
    mapping(uint8 => address[]) public poolRewardToWftmPaths;

    /**
     * @dev Variables for pool selection
     * {currentPoolId} - Pool id for the the current pool the strategy deposits xBoo into
     * {currentlyUsedPools} - A list of all pool ids currently being used by the strategy
     * {poolYield} - The estimated yield in wftm for each pool over the next 1 day
     * {hasAllocatedToPool} - If a given pool id has been deposited into already for a harvest cycle
     * {WFTM_POOL_ID} - Id for the wftm pool to use as default pool before pool selection
     * {maxPoolDilutionFactor} - The factor that determines what % of a pools total TVL can be deposited (to avoid dilution)
     */
    uint8 public currentPoolId;
    uint8[] public currentlyUsedPools;
    mapping(uint8 => uint256) public poolYield;
    mapping(uint8 => bool) public hasAllocatedToPool;
    uint8 private constant WFTM_POOL_ID = 2;
    uint8 public maxPoolDilutionFactor = 5;

    /**
     * @dev Variables for pool selection
     * {totalPoolBalance} - The total amount of xBoo currently deposited into pools
     * {poolxBooBalance} - The amount of xBoo deposited into each pool
     */
    uint256 public totalPoolBalance = 0;
    mapping(uint8 => uint256) public poolxBooBalance;

    /**
     * {StratHarvest} Event that is fired each time someone harvests the strat.
     * {TotalFeeUpdated} Event that is fired each time the total fee is updated.
     * {CallFeeUpdated} Event that is fired each time the call fee is updated.
     */
    event StratHarvest(address indexed harvester);
    event TotalFeeUpdated(uint256 newFee);
    event CallFeeUpdated(uint256 newCallFee, uint256 newTreasuryFee);

    /**
     * @dev Initializes the strategy. Sets parameters, saves routes, and gives allowances.
     * @notice see documentation for each variable above its respective declaration.
     */
    constructor(
        address _uniRouter,
        address _aceLab,
        address _rewardToken,
        address _xBoo,
        address _vault,
        address _treasury
    ) {
        uniRouter = _uniRouter;
        aceLab = _aceLab;
        boo = _rewardToken;
        xBoo = _xBoo;
        vault = _vault;
        treasury = _treasury;
        wftmToBooRoute = [wftm, boo];
        currentPoolId = WFTM_POOL_ID;

        _giveAllowances();
    }

    /**
     * @dev Function that puts the funds to work.
     * It gets called whenever someone deposits in the strategy's vault contract.
     * It deposits {boo} into xBoo (BooMirrorWorld) to farm {xBoo} and finally,
     * xBoo is deposited into other pools to earn additional rewards
     */
    function deposit() public whenNotPaused {
        uint256 booBalance = IERC20(boo).balanceOf(address(this));

        if (booBalance > 0) {
            IBooMirrorWorld(xBoo).enter(booBalance);
            uint256 xBooBalance = IERC20(xBoo).balanceOf(address(this));
            IAceLab(aceLab).deposit(currentPoolId, xBooBalance);
            totalPoolBalance = totalPoolBalance.add(xBooBalance);
            poolxBooBalance[currentPoolId] = poolxBooBalance[currentPoolId].add(
                xBooBalance
            );
        }
    }

    /**
     * @dev Withdraws funds and sents them back to the vault.
     * It withdraws {boo} from the AceLab pools.
     * The available {boo} minus fees is returned to the vault.
     */
    function withdraw(uint256 _amount) external {
        require(msg.sender == vault);

        uint256 booBalance = IERC20(boo).balanceOf(address(this));

        if (booBalance < _amount) {
            totalPoolBalance = currentlyUsedPools.withdraw(
                _amount,
                booBalance,
                totalPoolBalance,
                poolxBooBalance,
                aceLab,
                xBoo,
                boo
            );
        }

        if (booBalance > _amount) {
            booBalance = _amount;
        }
        uint256 withdrawFee = booBalance.mul(securityFee).div(PERCENT_DIVISOR);
        IERC20(boo).safeTransfer(vault, booBalance.sub(withdrawFee));
    }

    /**
     * @dev Core function of the strat, in charge of collecting and re-investing rewards.
     * 1. It claims rewards from the AceLab pools and estimated the current yield for each pool.
     * 2. It charges the system fees to simplify the split.
     * 3. It swaps the {wftm} token for {Boo} which is deposited into {xBoo}
     * 4. It distributes the xBoo using a yield optimization algorithm into various pools.
     */
    function harvest() external whenNotPaused {
        require(!Address.isContract(msg.sender));
        _collectRewardsAndEstimateYield();
        _chargeFees();
        _compoundRewards();
        _rebalance();
        emit StratHarvest(msg.sender);
    }

    /**
     * @dev Collects reward tokens from all used pools, swaps it into wftm and estimates
     * the yield for each pool.
     */
    function _collectRewardsAndEstimateYield() internal {
        currentlyUsedPools.collectRewardsAndEstimateYield(
            poolxBooBalance,
            hasAllocatedToPool,
            poolYield,
            aceLab,
            uniRouter
        );
        totalPoolBalance = 0;
    }

    /**
     * @dev Takes out fees from the rewards. Set by constructor
     * callFeeToUser is set as a percentage of the fee,
     * as is treasuryFeeToVault
     */
    function _chargeFees() internal {
        if (totalFee != 0) {
            uint256 wftmBalance = IERC20(wftm).balanceOf(address(this));
            uint256 wftmFee = wftmBalance.mul(totalFee).div(PERCENT_DIVISOR);

            uint256 callFeeToUser = wftmFee.mul(callFee).div(PERCENT_DIVISOR);
            IERC20(wftm).safeTransfer(msg.sender, callFeeToUser);

            uint256 treasuryFeeToVault = wftmFee.mul(treasuryFee).div(
                PERCENT_DIVISOR
            );
            IERC20(wftm).safeTransfer(treasury, treasuryFeeToVault);
        }
    }

    /**
     * @dev Swaps all {wftm} into {boo} which it deposits into {xBoo}
     */
    function _compoundRewards() internal {
        uint256 wftmBalance = IERC20(wftm).balanceOf(address(this));
        if (wftmBalance > 0) {
            IUniswapRouterETH(uniRouter)
                .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    wftmBalance,
                    0,
                    wftmToBooRoute,
                    address(this),
                    block.timestamp.add(600)
                );
            uint256 booBalance = IERC20(boo).balanceOf(address(this));
            IBooMirrorWorld(xBoo).enter(booBalance);
        }
    }

    /**
     * @dev Deposits into the highest yielding pool, up to a cap set by {maxPoolDilutionFactor}
     * If xBoo remains to be deposited picks the 2nd highest yielding pool and so on.
     */
    function _rebalance() internal {
        uint256 xBooBalance = IERC20(xBoo).balanceOf(address(this));
        while (xBooBalance > 0) {
            uint256 bestYield = 0;
            uint8 bestYieldPoolId = WFTM_POOL_ID;
            uint256 bestYieldIndex = 0;
            for (
                uint256 index = 0;
                index < currentlyUsedPools.length;
                index++
            ) {
                uint8 poolId = currentlyUsedPools[index];
                if (hasAllocatedToPool[poolId] == false) {
                    uint256 currentPoolYield = poolYield[poolId];
                    if (currentPoolYield >= bestYield) {
                        bestYield = currentPoolYield;
                        bestYieldPoolId = poolId;
                        bestYieldIndex = index;
                    }
                }
            }
            uint256 poolDepositAmount = xBooBalance;
            IAceLab.PoolInfo memory poolInfo = IAceLab(aceLab).poolInfo(
                bestYieldPoolId
            );
            bool isNotWFTM = address(poolInfo.RewardToken) != wftm;
            if (
                isNotWFTM &&
                poolDepositAmount >
                (poolInfo.xBooStakedAmount / maxPoolDilutionFactor)
            ) {
                poolDepositAmount =
                    poolInfo.xBooStakedAmount /
                    maxPoolDilutionFactor;
            }
            IAceLab(aceLab).deposit(bestYieldPoolId, poolDepositAmount);
            totalPoolBalance = totalPoolBalance.add(poolDepositAmount);
            poolxBooBalance[bestYieldPoolId] = poolxBooBalance[bestYieldPoolId]
                .add(poolDepositAmount);
            hasAllocatedToPool[bestYieldPoolId] = true;
            xBooBalance = IERC20(xBoo).balanceOf(address(this));
            currentPoolId = bestYieldPoolId;
        }
    }

    /**
     * @dev Function to calculate the total underlaying {boo} held by the strat.
     * It takes into account both the funds in hand, as the funds allocated in xBoo and the AceLab pools.
     */
    function balanceOf() public view returns (uint256) {
        uint256 balance = balanceOfBoo().add(
            balanceOfxBoo().add(balanceOfPool())
        );
        return balance;
    }

    /**
     * @dev It calculates how much {boo} the contract holds.
     */
    function balanceOfBoo() public view returns (uint256) {
        return IERC20(boo).balanceOf(address(this));
    }

    /**
     * @dev It calculates how much {boo} the contract has staked as xBoo.
     */
    function balanceOfxBoo() public view returns (uint256) {
        return IBooMirrorWorld(xBoo).BOOBalance(address(this));
    }

    /**
     * @dev It calculates how much {boo} the strategy has allocated in the AceLab pools
     */
    function balanceOfPool() public view returns (uint256) {
        return IBooMirrorWorld(xBoo).xBOOForBOO(totalPoolBalance);
    }

    /**
     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the
     * vault, ready to be migrated to the new strat.
     */
    function retireStrat() external {
        require(msg.sender == vault);

        currentlyUsedPools.withdrawAll(poolxBooBalance, aceLab, uniRouter);

        _compoundRewards();

        uint256 xBooBalance = IERC20(xBoo).balanceOf(address(this));
        IBooMirrorWorld(xBoo).leave(xBooBalance);

        uint256 booBalance = IERC20(boo).balanceOf(address(this));
        IERC20(boo).transfer(vault, booBalance);
    }

    /**
     * @dev Pauses deposits. Withdraws all funds from the AceLab contract, leaving rewards behind.
     */
    function panic() public onlyOwner {
        pause();
        currentlyUsedPools.emergencyWithdraw(aceLab);
        uint256 xBooBalance = IERC20(xBoo).balanceOf(address(this));
        IBooMirrorWorld(xBoo).leave(xBooBalance);

        uint256 booBalance = IERC20(boo).balanceOf(address(this));
        IERC20(boo).transfer(vault, booBalance);
    }

    /**
     * @dev Pauses the strat.
     */
    function pause() public onlyOwner {
        _pause();
        _removeAllowances();
    }

    /**
     * @dev Unpauses the strat.
     */
    function unpause() external onlyOwner {
        _unpause();

        _giveAllowances();

        deposit();
    }

    /**
     * @dev Gives max allowance of {boo} for the {xBoo} contract,
     * {xBoo} allowance for the {aceLab} contract,
     * {wftm} allowance for the {uniRouter}
     * in addition to allowance to all pool rewards for the {uniRouter}.
     */
    function _giveAllowances() internal {
        // Give xBOO permission to use Boo
        IERC20(boo).safeApprove(xBoo, 0);
        IERC20(boo).safeApprove(xBoo, type(uint256).max);
        // Give xBoo contract permission to stake xBoo
        IERC20(xBoo).safeApprove(aceLab, 0);
        IERC20(xBoo).safeApprove(aceLab, type(uint256).max);
        // Give uniRouter permission to swap wftm to boo
        IERC20(wftm).safeApprove(uniRouter, 0);
        IERC20(wftm).safeApprove(uniRouter, type(uint256).max);
        _givePoolAllowances();
    }

    /**
     * @dev Removes all allowance of {boo} for the {xBoo} contract,
     * {xBoo} allowance for the {aceLab} contract,
     * {wftm} allowance for the {uniRouter}
     * in addition to allowance to all pool rewards for the {uniRouter}.
     */
    function _removeAllowances() internal {
        // Give xBOO permission to use Boo
        IERC20(boo).safeApprove(xBoo, 0);
        // Give xBoo contract permission to stake xBoo
        IERC20(xBoo).safeApprove(aceLab, 0);
        // Give uniRouter permission to swap wftm to boo
        IERC20(wftm).safeApprove(uniRouter, 0);
        _removePoolAllowances();
    }

    /**
     * @dev Gives max allowance to all pool rewards for the {uniRouter}.
     */
    function _givePoolAllowances() internal {
        currentlyUsedPools.givePoolAllowances(aceLab, uniRouter);
    }

    /**
     * @dev Removes all allowance to all pool rewards for the {uniRouter}.
     */
    function _removePoolAllowances() internal {
        currentlyUsedPools.removePoolAllowances(aceLab, uniRouter);
    }

    /**
     * @dev updates the total fee, capped at 5%
     */
    function updateTotalFee(uint256 _totalFee)
        external
        onlyOwner
        returns (bool)
    {
        require(_totalFee <= MAX_FEE);
        totalFee = _totalFee;
        emit TotalFeeUpdated(totalFee);
        return true;
    }

    /**
     * @dev updates the call fee and adjusts the treasury fee to cover the difference
     */
    function updateCallFee(uint256 _callFee) external onlyOwner returns (bool) {
        callFee = _callFee;
        treasuryFee = PERCENT_DIVISOR.sub(callFee);
        emit CallFeeUpdated(callFee, treasuryFee);
        return true;
    }

    /**
     * @dev updates the treasury
     */
    function updateTreasury(address newTreasury)
        external
        onlyOwner
        returns (bool)
    {
        treasury = newTreasury;
        return true;
    }

    /**
     * @dev updates the {maxPoolDilutionFactor}
     */
    function updateMaxPoolDilutionFactor(uint8 _maxPoolDilutionFactor)
        external
        onlyOwner
    {
        require(_maxPoolDilutionFactor > 0);
        maxPoolDilutionFactor = _maxPoolDilutionFactor;
    }

    /**
     * @dev Adds a pool from the {aceLab} contract to be actively used to yield.
     * _poolRewardToWftmPaths can be empty if the paths are standard rewardToken -> wftm
     */
    function addUsedPool(uint8 _poolId, address[] memory _poolRewardToWftmPath)
        external
        onlyOwner
    {
        currentlyUsedPools.addUsedPool(
            _poolId,
            _poolRewardToWftmPath,
            poolRewardToWftmPaths,
            aceLab,
            uniRouter
        );
    }

    /**
     * @dev Removes a pool that will no longer be used.
     */
    function removeUsedPool(uint8 _poolIndex) external onlyOwner {
        totalPoolBalance = currentlyUsedPools.removeUsedPool(
            _poolIndex,
            totalPoolBalance,
            aceLab,
            uniRouter,
            poolxBooBalance
        );
    }
}
